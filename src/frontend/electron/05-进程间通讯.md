---
title: 05. 进程间通讯
icon: simple-icons:electron
---

# 05. 进程间通讯



提示

进程间通信 (IPC) 是在`Electron`中构建功能丰富的桌面应用程序的关键部分之一。 由于主进程和渲器进程在`Electron`的进程模型具有不同的职责，因此 IPC 是执行许多常见任务的唯一方法，例如从 UI 调用原生`API`或从原生菜单触发`Web`内容的更改。

### IPC 通道



在`Electron`中，进程使用`ipcMain`和`ipcRenderer`模块，通过开发人员定义的“通道”传递消息来进行通信。 这些通道是 任意和 双向 的。

### 模式 1：渲染器进程到主进程（单向）



要将单向 IPC 消息从渲染器进程发送到主进程，您可以使用`ipcRenderer.send API`发送消息，然后使用`ipcMain.on API`接收。

例:
- 使用 ipcMain.on 监听事件


在主进程中，使用 ipcMain.on API 在 set-title 通道上设置一个 IPC 监听器:

```javascript

const { app, BrowserWindow, ipcMain } = require ('electron')
const path = require ('path')

function handleSetTitle (event, title) {
 const webContents = event.sender
 const win = BrowserWindow.fromWebContents (webContents)
 win.setTitle (title)
}

function createWindow () {
 const mainWindow = new BrowserWindow ({
     webPreferences: {
         preload: path.join (__dirname, 'preload.js')
     }
 })
 mainWindow.loadFile ('index.html')
}

app.whenReady ().then (() => {
 ipcMain.on ('set-title', handleSetTitle)
 createWindow ()
})


上面的`handleSetTitle`回调函数有两个参数：一个`IpcMainEvent`和一个`title`字符串。每当消息通过`set-title`通道传入时，此函数找到附加到消息发送方的`BrowserWindow`实例，并在该实例上使用`win.setTitle API。`
- 通过预加载脚本暴露 ipcRenderer.send


要将消息发送到上面创建的监听器，您可以使用`ipcRenderer.send API`。 默认情况下，渲染器进程没有权限访问`Node.js`和`Electron`模块。 作为应用开发者，需要使用`contextBridge API`来选择要从预加载脚本中暴露哪些`API`。

预加载脚本中添加以下代码，向渲染器进程暴露一个全局的 window.electronAPI 变量。

```javascript
const { contextBridge, ipcRenderer } = require ('electron')

contextBridge.exposeInMainWorld ('electronAPI', {
    setTitle: (title) => ipcRenderer.send ('set-title', title)
})


此时，能够在渲染器进程中使用 window.electronAPI.setTitle() 函数。
- 构建渲染器进程 UI


在 BrowserWindow 加载的我们的 HTML 文件中，添加一个由文本输入框和按钮组成的基本用户界面

```html
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<!-- https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP -->
	<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'">
	<title>Hello World!</title>
</head>
<body>
Title: <input id="title"/>
<button id="btn" type="button">Set</button>
<script src="./renderer.js"></script>
</body>
</html>


为了使这些元素具有交互性，我们将在导入的 renderer.js 文件中添加几行代码，以利用从预加载脚本中暴露的 window.electronAPI 功能：

```javascript
const setButton = document.getElementById ('btn')
const titleInput = document.getElementById ('title')
setButton.addEventListener ('click', () => {
    const title = titleInput.value
    window.electronAPI.setTitle (title)
});


完整代码

效果


![](/Electron/10.jpg)


### 模式 2：渲染器进程到主进程（双向）



双向 IPC 的一个常见应用是从渲染器进程代码调用主进程模块并等待结果。 这可以通过将`ipcRenderer.invoke`与`ipcMain.handle`搭配使用来完成
- 使用 ipcMain.handle 监听事件


在主进程中，将创建一个`handleFileOpen()`函数，它调用`dialog.showOpenDialog`并返回用户选择的文件路径值。 每当渲染器进程通过`dialog:openFile`通道发送`ipcRender.invoke`消息时，此函数被用作一个回调。 然后，返回值将作为一个`Promise`返回到最初的`invoke`调用。

```javascript
main.js
const { app, BrowserWindow, ipcMain, dialog } = require ('electron')
const path = require ('path')

async function handleFileOpen () {
    const { canceled, filePaths } = await dialog.showOpenDialog ()
    if ( canceled ) {
        return
    } else {
        return filePaths[0]
    }
}

function createWindow () {
    const mainWindow = new BrowserWindow ({
        webPreferences: {
            preload: path.join (__dirname, 'preload.js')
        }
    })
    mainWindow.loadFile ('index.html')
}

app.whenReady ().then (() => {
    ipcMain.handle ('dialog:openFile', handleFileOpen)
    createWindow ()
    app.on ('activate', function () {
        if ( BrowserWindow.getAllWindows ().length === 0 ) createWindow ()
    })
})

app.on ('window-all-closed', function () {
    if ( process.platform !== 'darwin' ) app.quit ()
})



提示

IPC 通道名称上的 dialog: 前缀对代码没有影响。 它仅用作命名空间以帮助提高代码的可读性。
- 通过预加载脚本暴露 ipcRenderer.invoke


在预加载脚本中，我们暴露了一个单行的`openFile`函数，它调用并返回`ipcRenderer.invoke`('dialog:openFile') 的值。 我们将在下一步中使用此 API 从渲染器的用户界面调用原生对话框。

```javascript
preload.js
const { contextBridge, ipcRenderer } = require ('electron')

contextBridge.exposeInMainWorld ('electronAPI', {
    openFile: () => ipcRenderer.invoke ('dialog:openFile')
})


- 构建渲染器进程 UI


最后，构建加载到 BrowserWindow 中的 HTML 文件。

```html
index.html
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self'">
	<title>Dialog</title>
</head>
<body>
<button type="button" id="btn">Open a File</button>
File path: <strong id="filePath"></strong>
<script src="render.js"></script>
</body>
</html>


用户界面包含一个 #btn 按钮元素，将用于触发预加载 API，以及一个 #filePath 元素，将用于显示所选文件的路径。 要使这些部分起作用，需要在渲染器进程脚本中编写几行代码：

```javascript
renderer.js
const btn = document.getElementById ('btn')
const filePathElement = document.getElementById ('filePath')

btn.addEventListener ('click', async () => {
    const filePath = await window.electronAPI.openFile ()
    filePathElement.innerText = filePath
})



监听 #btn 按钮的点击，并调用 window.electronAPI.openFile() API 来激活原生的打开文件对话框。 然后在 #filePath 元素中显示选中文件的路径。


![](/Electron/11.jpg)