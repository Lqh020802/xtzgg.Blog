---
title: 03. 流程模型
icon: simple-icons:electron
---

# 03. 流程模型

Electron 继承了来自 Chromium 的多进程架构，这使得此框架在架构上非常相似于一个现代的网页浏览器。

### 为什么不是一个单一的进程？

网页浏览器是个极其复杂的应用程序。 除了显示网页内容的主要能力之外，他们还有许多次要的职责，例如：管理众多窗口 ( 或 标签页 ) 和加载第三方扩展。

在早期，浏览器通常使用单个进程来处理所有这些功能。 虽然这种模式意味着您打开每个标签页的开销较少，但也同时意味着一个网站的崩溃或无响应会影响到整个浏览器。

### 多进程模型

为了解决这个问题，`Chrome`团队决定让每个标签页在自己的进程中渲染， 从而限制了一个网页上的有误或恶意代码可能导致的对整个应用程序造成的伤害。 然后用单个浏览器进程控制这些标签页进程，以及整个应用程序的生命周期。下方来自`Chrome`漫画 的图表可视化了此模型

![](https://www.electronjs.org/zh/assets/images/chrome-processes-0506d3984ec81aa39985a95e7a29fbb8.png)

`Electron`应用程序的结构非常相似。 作为应用开发者，控制着两种类型的进程：主进程和渲染进程。 这些类似于上面概述的`Chrome`自己的浏览器和其渲染器进程。

### 主进程

每个`Electron`应用都有一个单一的主进程，作为应用程序的入口点。 主进程在 Node.js 环境中运行，这意味着它具有`require`模块和使用所有`Node.js API`的能力。

#### 窗口管理

主进程的主要目的是使用**`BrowserWindow`**模块创建和管理应用程序窗口。

`BrowserWindow`类的每个实例创建一个应用程序窗口，且在单独地渲染器进程中加载一个网页。可从主进程用`window`的**`webContent`**对象与网页内容进行交互。

当一个`BrowserWindow`实例被销毁时，它对应的渲染进程也会被终止。

```javascript
// 导入两个electron模块
const { app, BrowserWindow } = require ('electron')
const path = require ('path')

// 创建一个createWindow()函数，用于将index.html加载到新BrowserWindow实例中
const createWindow = () => {
    const win = new BrowserWindow ({
        width: 800,
        height: 600,
        webPreferences: {
            preload: path.join (__dirname, 'preload.js')
        }
    })
    win.loadURL ('https://www.csdn.net/').then (r => {
        const contents = win.webContents
        console.log (contents)
    })
}
// 调用这个createWindow()函数来打开窗口
app.whenReady ().then (() => {
    createWindow ()
})

```

由于`BrowserWindow`模块是一个`EventEmitter`， 所以您也可以为各种用户事件 ( 例如，最小化 或 最大化您的窗口 ) 添加处理程序。

提示

`EventEmitter`的核心就是事件触发与事件监听器功能的封装。

#### 应用程序生命周期

主进程还能通过`Electron`的`app`模块来控制您应用程序的生命周期。 该模块提供了一整套的事件和方法，可以使你添加自定义的应用程序行为 ( 例如，以编程退出应用程序的方式、修改应用程序上方的选项菜单等 ) 。

#### 原生 API

为了使`Electron`的功能不仅仅限于对网页内容的封装，主进程也添加了自定义的 API 来与用户的作业系统进行交互。`Electron`有着多种控制原生桌面功能的模块，例如菜单、对话框以及托盘图标。

提示

[Api文档](https://www.electronjs.org/zh/docs/latest/api/app)

### 渲染器进程

每个`Electron`应用都会为每个打开的`BrowserWindow`( 与每个网页嵌入 ) 生成一个单独的渲染器进程。 洽如其名，渲染器负责`渲染`网页内容。 所以实际上，运行于渲染器进程中的代码是须遵照网页标准

一个浏览器窗口中的所有的用户界面和应用功能，都应与您在网页开发上使用相同的工具和规范来进行编写。
- 以一个`HTML`文件作为渲染器进程的入口点。
- 使用层叠样式表`CSS`对`UI`添加样式。
- 通过`script`元素可添加可执行的`JavaScript`代码。

这也意味着渲染器无法直接访问`require`或其他`Node.js API`。 为了在渲染器中直接包含`NPM`模块，必须使用与在`web`开发时使用相同的打包工具 (例如`webpack`或`parcel`)

警告

注意：渲染器进程可以生成一个完整的 Node.js 环境以便于开发。 在过去这是默认的，但如今此功能考虑到安全问题已经被禁用。

### Preload 脚本

`预加载（preload）脚本`包含了那些执行于渲染器进程中，且先于网页内容开始加载的代码 。这些脚本虽运行于渲染器的环境中，却因能访问`Node.js API`而拥有了更多的权限。

预加载脚本可以在`BrowserWindow`构造方法中的`webPreferences`选项里被附加到主进程。

```javascript
main.js
const { BrowserWindow } = require ('electron')

const win = new BrowserWindow ({
    webPreferences: {
        preload: 'path/to/preload.js'
    }
})

```

因为预加载脚本与渲染器共享一个全局的window对象，并且可以访问Node.js api，它通过在`Window global`中公开任意api来增强你的渲染器，你的`web`内容可以使用这些`api`。但这 要注意，尽管预加载脚本与它们所连接的渲染器共享一个全局窗口，但由于`contextIsolation`默认 值使上下文隔离的缘故，不能直接将任何变量从预加载脚本连接到窗口。

例: preload.js里面编写自己的接口：

```javascript
preload.js
window.myAPI = {
    desktop: true
}

```

然后再创建一个叫index.js的脚本，编写代码获取preload.js预加载脚本里的自己编写的接口，并把它通过script标签引到index.html页面中去：

```javascript
index.js
console.log (window.myAPI)
// => undefined

```

```html
index.html
<script src="./index.js"></script>

```

会发现打印的确是undefined，myAPI的值并没有被取到。

上下文隔离`（Context Isolation）`意味着预加载脚本与渲染器的主要运行环境是隔离开来的，以避免泄漏任何具特权的 API 到您的网页内容代码中。

使用`contextBridge`模块来安全地完成这个任务

```javascript
preload.js

const { contextBridge } = require ('electron')

contextBridge.exposeInMainWorld ('myAPI', {
    desktop: true
})

```

```javascript
index.js
console.log (window.myAPI)
// => { desktop: true }

```

此功能对两个主要目的来说非常有用：

通过暴露`ipcRenderer`模块于渲染器中，您以使用 进程 通讯 ( inter-process communication, IPC ) 来从渲染器触发主进程任务 ( 反之亦然 ) 。 如果正在为远程`URL`上托管的现有`web`应用开发`Electron`封裝，则您可在渲染器的`window`全局变量上添加自定义的属性，好在`web`客户端用上仅适用于桌面应用的设计逻辑